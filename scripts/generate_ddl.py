import re
import os

# --- 設定 ---
# プロジェクトのルートからの相対パスを定義
ER_MD_PATH = 'docs/er.md' # 参照するファイルをer.mdに変更
OUTPUT_SQL_PATH = 'output.sql'
# --- 設定ここまで ---

def parse_er_diagram(markdown_content):
    """MarkdownコンテンツからMermaidのER図ブロックを抽出する"""
    # er.mdファイル全体をER図ブロックとして扱うこともできるが、
    # ファイル内にコメントなどを書けるようにするため、このロジックは維持する
    er_diagram_regex = re.compile(r"```mermaid\s*erDiagram\s*([\s\S]*?)\s*```", re.IGNORECASE)
    match = er_diagram_regex.search(markdown_content)
    if not match:
        return None
    return match.group(1)

def generate_ddl_from_mermaid(mermaid_content):
    """MermaidのER図テキストからCREATE TABLE文を生成する"""
    ddl_statements = []
    # Mermaidのテーブル定義を抽出 (例: USERS { ... })
    table_regex = re.compile(r"(\w+)\s*\{([\s\S]*?)\}", re.MULTILINE)
    
    tables = table_regex.finditer(mermaid_content)
    
    for table in tables:
        table_name = table.group(1).strip()
        columns_str = table.group(2).strip()
        
        columns = []
        primary_keys = []
        
        # カラムの行を分割
        lines = columns_str.split('\n')
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            # カラム定義を解析 (例: int id PK "AUTO_INCREMENT")
            parts = line.split()
            if len(parts) < 2:
                continue
                
            col_type = parts[0]
            col_name = parts[1]
            constraints = ""
            
            # 制約（PK, FK, NNなど）とコメントを解析
            constraint_parts = parts[2:]
            is_pk = False
            
            for i, part in enumerate(constraint_parts):
                if part.upper() == 'PK':
                    is_pk = True
                    primary_keys.append(col_name)
                elif part.upper() == 'FK':
                    # FKはリレーションシップ定義から設定する方が正確なため、ここでは無視
                    pass
                elif part.upper() == 'NN':
                    constraints += " NOT NULL"
                elif part.upper() == 'UNIQUE':
                     constraints += " UNIQUE"
                # コメント部分 (例: "AUTO_INCREMENT")
                elif part.startswith('"') and part.endswith('"'):
                    comment_content = part[1:-1]
                    if "AUTO_INCREMENT" in comment_content.upper(): # MySQL/SQLite
                        constraints += " AUTO_INCREMENT" # MySQL
                        # PostgreSQLの場合は SERIAL or BIGSERIAL, SQLiteの場合は AUTOINCREMENT
                    # ここで他のDBMSのコメントも解釈可能
            
            columns.append(f"    `{col_name}` {col_type.upper()}{constraints}")

        # CREATE TABLE文を組み立て
        columns_sql = ",\n".join(columns)
        if primary_keys:
            pk_sql = f",\n    PRIMARY KEY (`{', '.join(primary_keys)}`)"
        else:
            pk_sql = ""
            
        create_statement = f"CREATE TABLE `{table_name}` (\n{columns_sql}{pk_sql}\n);\n"
        ddl_statements.append(create_statement)
        
    return "\n".join(ddl_statements)

def main():
    """メイン処理"""
    print("er.mdからDDLの生成を開始します...")
    
    try:
        with open(ER_MD_PATH, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"エラー: {ER_MD_PATH} が見つかりません。")
        return

    mermaid_block = parse_er_diagram(content)
    
    if not mermaid_block:
        print(f"{ER_MD_PATH}内にMermaid形式のER図が見つかりませんでした。")
        return
        
    ddl = generate_ddl_from_mermaid(mermaid_block)
    
    if not ddl:
        print("ER図からDDLを生成できませんでした。")
        return

    try:
        with open(OUTPUT_SQL_PATH, 'w', encoding='utf-8') as f:
            f.write("-- Generated by Specdeck's generate_ddl.py\n\n")
            f.write(ddl)
        print(f"成功: DDLを '{OUTPUT_SQL_PATH}' に出力しました。")
    except IOError as e:
        print(f"エラー: ファイルの書き込みに失敗しました - {e}")


if __name__ == "__main__":
    main()

